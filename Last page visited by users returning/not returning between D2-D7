drop table if exists returned_users ;
create temp table returned_users as
SELECT
    DISTINCT CASE WHEN ( dw_user_events_daily.is_active  ) AND ( dw_user_events_daily.is_valid_user  ) AND (NOT COALESCE(( coalesce((datediff(day,(coalesce(dw_users.guest_joined_at, dw_users.joined_at)),(CASE WHEN dw_users.user_status = 'restricted' THEN dw_users.status_updated_at ELSE NULL END)) + 1) <= 30, FALSE)  ), FALSE)) THEN dw_user_events_daily.user_id  ELSE NULL END  AS "user_id",
    (DATE(dw_user_events_daily.enrolled_joined_at )) AS "joined_date",
        (DATE(dw_user_events_daily.event_date )) AS "event_date_date"
FROM analytics.dw_user_events_daily  AS dw_user_events_daily
LEFT JOIN analytics.dw_users  AS dw_users ON dw_user_events_daily.user_id  = dw_users.user_id
WHERE ((( dw_user_events_daily.enrolled_joined_at  ) >= ((TIMESTAMP '2024-04-01')) AND ( dw_user_events_daily.enrolled_joined_at  ) < ((DATEADD(day,1, TIMESTAMP '2024-04-01' ))))) AND ((( CASE
WHEN coalesce(dw_user_events_daily.enrolled_home_domain,'us')='us'  THEN 'us'
WHEN dw_user_events_daily.enrolled_home_domain='ca'  THEN 'ca'
WHEN dw_user_events_daily.enrolled_home_domain='au'  THEN 'au'
WHEN dw_user_events_daily.enrolled_home_domain='in'  THEN 'in'
WHEN dw_user_events_daily.enrolled_home_domain='uk'  THEN 'uk'
ELSE 'New Home Domain'
END ) ILIKE  'us') AND (( CASE
WHEN dw_user_events_daily.enrolled_reg_app in ('iphone','ipad')  THEN 'iOS'
WHEN dw_user_events_daily.enrolled_reg_app = 'android'  THEN 'Android'
WHEN dw_user_events_daily.enrolled_reg_app = 'web'  THEN 'Web'
ELSE 'Other'
END ) ILIKE  'iOS')) AND ((((( datediff(day,(DATE(dw_user_events_daily.enrolled_joined_at )),(DATE(dw_user_events_daily.event_date )))+1  ) >= 2 AND ( datediff(day,(DATE(dw_user_events_daily.enrolled_joined_at )),(DATE(dw_user_events_daily.event_date )))+1  ) <= 7)))  AND ((NOT (coalesce((datediff(day,(coalesce(dw_users.guest_joined_at, dw_users.joined_at)),(CASE WHEN dw_users.user_status = 'restricted' THEN dw_users.status_updated_at ELSE NULL END)) + 1) <= 30, FALSE) ) OR (coalesce((datediff(day,(coalesce(dw_users.guest_joined_at, dw_users.joined_at)),(CASE WHEN dw_users.user_status = 'restricted' THEN dw_users.status_updated_at ELSE NULL END)) + 1) <= 30, FALSE) ) IS NULL) AND ((coalesce(dw_user_events_daily.app, 'unknown')) in ('unknown','iphone','ipad','external','android','web') )))
GROUP BY
    1,
    2,3
ORDER BY
    1
;

drop table if exists returned_user_activity ;
create temp table returned_user_activity as
select   returned_users.joined_date as date ,
      (TIMESTAMP 'epoch' + r.at * INTERVAL '1 second') as time_stamp,
       r.direct_object.name as page_viewed,r.verb as verb,
       returned_users.user_id as user_id,
       rank() over (partition by user_id order by time_stamp ) as rank_users
from returned_users
inner join external_spark_tables.raw_events r on returned_users.user_id =  r.actor.id and returned_users.joined_date = r.event_date
where
r.verb in('view','click')
and r.using.app_type in ('iphone','ipad')
and r.using.domain in ('us')
and r.actor.id is not null
and r.direct_object.name is not null
and r.actor.type in ('user')
and returned_users.joined_date = '2024-04-01'
group by 1,2,3,4,5
order by 2 ,5  ;

drop table if exists last ;
create temp table last as
select distinct user_id,max(rank_users ),time_stamp as r
from returned_user_activity
group by 1,3 ;
--select * from last limit 50;

with x as (
select returned_user_activity.user_id,returned_user_activity.page_viewed,last.r
from returned_user_activity
join last on returned_user_activity.user_id = last.user_id and returned_user_activity.rank_users = last.r )
select distinct user_id,page_viewed  from x
group by 1,2
order by 2 desc;
--
drop table if exists not_returned ;
create temp table not_returned as
SELECT distinct user_id,new_users.joined_date
from new_users LEFT JOIN returned_users using (user_id) where returned_users.user_id is null ;
--
drop table if exists not_returned_user_activity ;
create temp table not_returned_user_activity as
select   not_returned.joined_date as date ,
      (TIMESTAMP 'epoch' + r.at * INTERVAL '1 second') as time_stamp,
       r.direct_object.name as page_viewed,r.verb as verb,
       not_returned.user_id as user_id,
       rank() over (partition by user_id order by time_stamp ) as rank_users
from not_returned
inner join external_spark_tables.raw_events r on not_returned.user_id =  r.actor.id and not_returned.joined_date = r.event_date
where
r.verb in('view','click')
and r.using.app_type in ('iphone','ipad')
and r.using.domain in ('us')
and r.actor.id is not null
and r.direct_object.name is not null
and r.actor.type in ('user')
and not_returned.joined_date = '2024-04-01'
group by 1,2,3,4,5
order by 2 ,5  ;

select * from not_returned_user_activity limit 30;
select count(distinct user_id) from not_returned_user_activity ;
--Last activity done by the users not returning  on the D2
drop table if exists last ;
create temp table last as
select distinct user_id,max(rank_users ) as r
from not_returned_user_activity
group by 1 ;
with x as (
select not_returned_user_activity.user_id,not_returned_user_activity.page_viewed,last.r
from not_returned_user_activity
join last on not_returned_user_activity.user_id = last.user_id and not_returned_user_activity.rank_users = last.r )
select distinct user_id,page_viewed  from x
group by 1,2
order by 2 desc;
